        -:    0:Source:graph.c
        -:    0:Graph:graph_cov-graph.gcno
        -:    0:Data:graph_cov-graph.gcda
        -:    0:Runs:15
        -:    1:// Example: ./euler_graph 8 6 42 -p
        -:    2:
        -:    3:#define _XOPEN_SOURCE 700
        -:    4:#include <stdio.h>
        -:    5:#include <stdlib.h>
        -:    6:#include <string.h>
        -:    7:#include <unistd.h>     // getopt
        -:    8:#include <time.h>
        -:    9:#include <math.h>
        -:   10:#include <errno.h>
        -:   11:
        -:   12:typedef struct {
        -:   13:    int V;      // number of vertices
        -:   14:    int E;      // number of edges
        -:   15:    int **adj;  // adjacency matrix (0/1), undirected
        -:   16:} Graph;
        -:   17:
        -:   18:/*------------------ Graph utils ------------------*/
        -:   19:
function create_graph called 12 returned 100% blocks executed 57%
       12:   20:static Graph* create_graph(int V) {
       12:   21:    Graph *g = malloc(sizeof(Graph));
      12*:   22:    if (!g) { perror("malloc"); exit(1); }
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
call    3 never executed
       12:   23:    g->V = V;
       12:   24:    g->E = 0;
       12:   25:    g->adj = malloc(V * sizeof(int*));
      12*:   26:    if (!g->adj) { perror("malloc"); exit(1); }
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
call    3 never executed
       73:   27:    for (int i = 0; i < V; ++i) {
branch  0 taken 84%
branch  1 taken 16% (fallthrough)
       61:   28:        g->adj[i] = calloc(V, sizeof(int));
      61*:   29:        if (!g->adj[i]) { perror("calloc"); exit(1); }
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
call    3 never executed
        -:   30:    }
       12:   31:    return g;
        -:   32:}
        -:   33:
function free_graph called 11 returned 100% blocks executed 86%
       11:   34:static void free_graph(Graph *g) {
      11*:   35:    if (!g) return;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       68:   36:    for (int i = 0; i < g->V; ++i) free(g->adj[i]);
branch  0 taken 84%
branch  1 taken 16% (fallthrough)
       11:   37:    free(g->adj);
       11:   38:    free(g);
        -:   39:}
        -:   40:
function add_edge called 55 returned 100% blocks executed 91%
       55:   41:static int add_edge(Graph *g, int u, int v) {
      55*:   42:    if (u < 0 || v < 0 || u >= g->V || v >= g->V) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
       55:   43:    if (u == v) return 0;              // no self-loops
branch  0 taken 18% (fallthrough)
branch  1 taken 82%
       45:   44:    if (g->adj[u][v]) return 0;        // no multiedges
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
       33:   45:    g->adj[u][v] = 1;
       33:   46:    g->adj[v][u] = 1;
       33:   47:    g->E++;
       33:   48:    return 1;
        -:   49:}
        -:   50:
function degree called 190 returned 100% blocks executed 100%
      190:   51:static int degree(const Graph *g, int u) {
      190:   52:    int d = 0;
     1183:   53:    for (int v = 0; v < g->V; ++v) d += g->adj[u][v];
branch  0 taken 84%
branch  1 taken 16% (fallthrough)
      190:   54:    return d;
        -:   55:}
        -:   56:
function print_graph called 2 returned 100% blocks executed 100%
        2:   57:static void print_graph(const Graph *g) {
        2:   58:    printf("Graph: V=%d, E=%d\nAdjacency matrix:\n", g->V, g->E);
call    0 returned 100%
       12:   59:    for (int i = 0; i < g->V; ++i) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
       60:   60:        for (int j = 0; j < g->V; ++j) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
       50:   61:            printf("%d ", g->adj[i][j]);
call    0 returned 100%
        -:   62:        }
       10:   63:        printf("\n");
call    0 returned 100%
        -:   64:    }
        2:   65:}
        -:   66:
        -:   67:/*------------------ Random graph generator ------------------*/
        -:   68:
function generate_random_graph called 12 returned 92% blocks executed 100%
       12:   69:static void generate_random_graph(Graph *g, int targetE, unsigned int seed) {
       12:   70:    srand(seed);
call    0 returned 100%
       12:   71:    const long long maxE = (long long)g->V * (g->V - 1) / 2;
       12:   72:    if (targetE > maxE) {
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
        1:   73:        fprintf(stderr, "Error: cannot place %d edges in a simple graph with V=%d (max=%lld)\n",
call    0 returned 100%
        -:   74:                targetE, g->V, maxE);
        1:   75:        exit(1);
call    0 returned 0%
        -:   76:    }
       66:   77:    while (g->E < targetE) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
       55:   78:        int u = rand() % g->V;
call    0 returned 100%
       55:   79:        int v = rand() % g->V;
call    0 returned 100%
       55:   80:        if (add_edge(g, u, v)) { /* added */ }
call    0 returned 100%
        -:   81:    }
       11:   82:}
        -:   83:
        -:   84:/*------------------ Connectivity ------------------*/
        -:   85:
function dfs called 34 returned 100% blocks executed 100%
       34:   86:static void dfs(const Graph *g, int u, int *visited) {
       34:   87:    visited[u] = 1;
      220:   88:    for (int v = 0; v < g->V; ++v) {
branch  0 taken 85%
branch  1 taken 15% (fallthrough)
      186:   89:        if (g->adj[u][v] && !visited[v]) dfs(g, v, visited);
branch  0 taken 45% (fallthrough)
branch  1 taken 55%
branch  2 taken 31% (fallthrough)
branch  3 taken 69%
call    4 returned 100%
        -:   90:    }
       34:   91:}
        -:   92:
function connected_among_non_isolated called 16 returned 100% blocks executed 100%
       16:   93:static int connected_among_non_isolated(const Graph *g) {
       16:   94:    int start = -1;
       58:   95:    for (int i = 0; i < g->V; ++i) if (degree(g, i) > 0) { start = i; break; }
call    0 returned 100%
branch  1 taken 16% (fallthrough)
branch  2 taken 84%
branch  3 taken 86%
branch  4 taken 14% (fallthrough)
       16:   96:    if (start == -1) return 1; // no edges
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        8:   97:    int *visited = calloc(g->V, sizeof(int));
        8:   98:    dfs(g, start, visited);
call    0 returned 100%
        8:   99:    int ok = 1;
       46:  100:    for (int i = 0; i < g->V; ++i) {
branch  0 taken 85%
branch  1 taken 15% (fallthrough)
       39:  101:        if (degree(g, i) > 0 && !visited[i]) { ok = 0; break; }
call    0 returned 100%
branch  1 taken 87% (fallthrough)
branch  2 taken 13%
branch  3 taken 3% (fallthrough)
branch  4 taken 97%
        -:  102:    }
        8:  103:    free(visited);
        8:  104:    return ok;
        -:  105:}
        -:  106:
        -:  107:/*------------------ Euler circuit ------------------*/
        -:  108:
function all_even_degrees called 5 returned 100% blocks executed 88%
        5:  109:static int all_even_degrees(const Graph *g) {
       30:  110:    for (int i = 0; i < g->V; ++i)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      25*:  111:        if (degree(g, i) % 2 != 0) return 0;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        5:  112:    return 1;
        -:  113:}
        -:  114:
function euler_circuit called 5 returned 100% blocks executed 94%
        5:  115:static int euler_circuit(const Graph *g, int **path_out, int *path_len_out) {
       5*:  116:    if (!connected_among_non_isolated(g)) return 0;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
       5*:  117:    if (!all_even_degrees(g)) return 0;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  118:
        5:  119:    int **adj = malloc(g->V * sizeof(int*));
       30:  120:    for (int i = 0; i < g->V; ++i) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
       25:  121:        adj[i] = malloc(g->V * sizeof(int));
       25:  122:        memcpy(adj[i], g->adj[i], g->V * sizeof(int));
        -:  123:    }
        5:  124:    int *deg = malloc(g->V * sizeof(int));
       30:  125:    for (int i = 0; i < g->V; ++i) deg[i] = degree(g, i);
call    0 returned 100%
branch  1 taken 83%
branch  2 taken 17% (fallthrough)
        -:  126:
        5:  127:    int start = 0;
       25:  128:    for (int i = 0; i < g->V; ++i) if (deg[i] > 0) { start = i; break; }
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
branch  2 taken 84%
branch  3 taken 16% (fallthrough)
        -:  129:
        5:  130:    int stackCap = g->E + 2, *stack = malloc(stackCap * sizeof(int)), top = 0;
        5:  131:    int outCap = g->E + 2, *out = malloc(outCap * sizeof(int)), outLen = 0;
        -:  132:
        5:  133:    stack[top++] = start;
       30:  134:    while (top > 0) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
       25:  135:        int u = stack[top - 1], v = -1;
       25:  136:        if (deg[u] > 0) {
branch  0 taken 40% (fallthrough)
branch  1 taken 60%
       30:  137:            for (int w = 0; w < g->V; ++w) if (adj[u][w]) { v = w; break; }
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
        -:  138:        }
       25:  139:        if (v != -1) {
branch  0 taken 40% (fallthrough)
branch  1 taken 60%
       10:  140:            adj[u][v]--; adj[v][u]--;
       10:  141:            deg[u]--; deg[v]--;
       10:  142:            stack[top++] = v;
        -:  143:        } else {
       15:  144:            out[outLen++] = u;
       15:  145:            top--;
        -:  146:        }
        -:  147:    }
        -:  148:
       30:  149:    for (int i = 0; i < g->V; ++i) free(adj[i]);
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        5:  150:    free(adj); free(deg);
        -:  151:
        5:  152:    *path_out = out;
        5:  153:    *path_len_out = outLen;
        5:  154:    free(stack);
        5:  155:    return 1;
        -:  156:}
        -:  157:
        -:  158:/*------------------ Main ------------------*/
        -:  159:
function main called 15 returned 93% blocks executed 100%
       15:  160:int main(int argc, char **argv) {
       15:  161:    if (argc < 3) {
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
        1:  162:        fprintf(stderr, "Usage: %s <edges> <vertices> [seed] [-p]\n", argv[0]);
call    0 returned 100%
        1:  163:        return 1;
        -:  164:    }
        -:  165:
       14:  166:    int E = atoi(argv[1]);
       14:  167:    int V = atoi(argv[2]);
       11:  168:    unsigned int seed = (argc >= 4 && argv[3][0] != '-') ?
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
       28:  169:        (unsigned int)strtoul(argv[3], NULL, 10) :
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
call    2 returned 100%
        4:  170:        (unsigned int)time(NULL);
call    0 returned 100%
       14:  171:    int printAdj = 0;
        -:  172:
       56:  173:    for (int i = 1; i < argc; i++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
       42:  174:        if (strcmp(argv[i], "-p") == 0) printAdj = 1;
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
        -:  175:    }
        -:  176:
       14:  177:    if (V < 1 || E < 0) {
branch  0 taken 93% (fallthrough)
branch  1 taken 7%
branch  2 taken 8% (fallthrough)
branch  3 taken 92%
        2:  178:        fprintf(stderr, "Invalid vertices or edges\n");
call    0 returned 100%
        2:  179:        return 1;
        -:  180:    }
        -:  181:
       12:  182:    Graph *g = create_graph(V);
call    0 returned 100%
       12:  183:    generate_random_graph(g, E, seed);
call    0 returned 92%
        -:  184:
       11:  185:    if (printAdj) print_graph(g);
branch  0 taken 18% (fallthrough)
branch  1 taken 82%
call    2 returned 100%
        -:  186:
       11:  187:    if (!connected_among_non_isolated(g)) {
call    0 returned 100%
branch  1 taken 9% (fallthrough)
branch  2 taken 91%
        1:  188:        printf("No Euler circuit: graph is disconnected among non-isolated vertices.\n");
call    0 returned 100%
        1:  189:        free_graph(g);
call    0 returned 100%
        1:  190:        return 0;
        -:  191:    }
        -:  192:
       10:  193:    int oddCount = 0;
       61:  194:    for (int i = 0; i < g->V; ++i) if (degree(g, i) % 2 != 0) oddCount++;
call    0 returned 100%
branch  1 taken 31% (fallthrough)
branch  2 taken 69%
branch  3 taken 84%
branch  4 taken 16% (fallthrough)
       10:  195:    if (oddCount != 0) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        5:  196:        printf("No Euler circuit: %d vertices have odd degree.\n", oddCount);
call    0 returned 100%
        5:  197:        free_graph(g);
call    0 returned 100%
        5:  198:        return 0;
        -:  199:    }
        -:  200:
        5:  201:    int *path = NULL, pathLen = 0;
        5:  202:    euler_circuit(g, &path, &pathLen);
call    0 returned 100%
        -:  203:
        -:  204:
        5:  205:    printf("Euler circuit exists. Sequence of vertices:\n");
call    0 returned 100%
       20:  206:    for (int i = 0; i < pathLen; ++i) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
       15:  207:        printf("%d%s", path[i], (i + 1 == pathLen ? "\n" : " -> "));
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
call    2 returned 100%
        -:  208:    }
        -:  209:
        5:  210:    free(path);
        5:  211:    free_graph(g);
call    0 returned 100%
        5:  212:    return 0;
        -:  213:}
